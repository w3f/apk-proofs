<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>specification</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1>APK Proofs</h1>
<p>APK proofs are SNARK based proof protocols to enable verification of aggregated BLS signatures without the knowledge of individual public keys of all the signers. APK proofs uses its own custom SNARK. The protocol is implemented in two flavours: <a href="#BW6">BW6</a> and <a href="#MIPP">MIPP</a> which are specified in the following sections.</p>
<h2>BW6</h2>
<h3>Preliminaries</h3>
<p>In this section we describe the preliminary data structure which are being used by APK prover and verifier.</p>
<h4>The Key Set</h4>
<p>In short, APK proof provides polynomial commitment to the vector of public keys. Furthermore, it offers the mean to use this commitment to verify BLS signatures signed by the subset of those public keys. As a result, the verifier does not need to know the public keys to verify aggregated BLS signature signed by them.</p>
<p>In light client protocols, such commitment is used to commit to the upcoming validator set, signed by the current validator set. Honest validator should check the proofs of possession of each public key belong to an upcoming validator and arrange them in a sequence with a determistic order. They then should deterministically pad the sequence to get a vector of consistent length of the right domain which they use to interpolate the polynomial and to compute the commitment using the right parameters, and then sign it.</p>
<p>Verifier checks the signatures and can trust that the properties hold under some "2/3 honest validators" assumption. As every honest validator generates the same commitment, verifier needs to check only the aggregate signature.</p>
<p>As such the fundamental structure used is the set of public keys which prover has to commit to. The <code>Keyset</code> struct represent that set. Whereas <code>KeysetCommitment</code> struct is used to store prover's commitment to the key set.</p>
<p>Let 'pks' be such a vector that</p>
<p>commit(pks) == KeysetCommitment::pks_comm,</p>
<p>also let:</p>
<p><code>domain_size := KeysetCommitment::domain.size</code></p>
<p>and</p>
<p><code>keyset_size := KeysetCommitment::keyset_size</code></p>
<p>Then the verifier needs to trust that:</p>
<ol type="1">
<li>The following:
<ul>
<li><code>pks.len() == KeysetCommitment::domain.size</code></li>
<li><code>pks[i]</code> lie in BLS12-377 G1 for <code>i=0,...,domain_size-2</code></li>
<li>For the 'real' <code>keys pks[i]</code>, <code>i=0,...,keyset_size-1</code>, there exist proofs of possession</li>
<li>For the padding, <code>pks[i], i=keyset_size,...,domain_size-2</code>, `dlog is not known, e.g. pks[i] = hash_to_g1("something").</li>
<li><code>pks[domain_size-1]</code> is not a part of the relation (not constrained) and can be anything, we set pks[domain_size-1] = (0,0), not even a curve point.</li>
</ul></li>
<li><code>KeysetCommitment::domain</code> is the domain used to interpolate pks</li>
</ol>
<p><em>pks_comm</em>: Per-coordinate KZG commitments to a vector of BLS public keys on BLS12-377 represented in affine. $$(<a href="{\tau}">pkx</a>, <a href="{\tau}">pky</a>$$ where:</p>
<p>$$pkx(X) = \sum_{i=0}^{n-1} pkx_i \cdot L_i(X).$$ $$pky(X) = \sum_{i=0}^{n-1} pky_i \cdot L_i(X).$$ Domain used to interpolate the vectors above. Radix2 Domain Works only for fields that have a large multiplicative subgroup of size that is a power-of-2. The actual size of keyset i.e. the number of possible signers in contrast to the size of keyset vector after padding Actual public keys in form of Projective Points on G1, no padding. Interpolations of the coordinate vectors of the public key vector which includes dummy padded keys Domain used to compute the interpolations above. Polynomials above, evaluated over a 4-times larger domain. Used by the prover to populate the AIR execution trace.</p>
<h3>Prover</h3>
<p>Prover is responsible to generate APK proofs. The <code>Prover</code> struct encapsultes this task. It contains the following fields:</p>
<ul>
<li><code>Domains</code>: ???</li>
<li><code>Keyset</code>: set of all committe public keys (?)</li>
<li><code>KzgCommitterKey</code>: the set points in G1 corresponding to $\tau^n G_1$.</li>
<li><code>Transcript</code>: Representing the statement which purportedly has been signed by the aggregated public key. Prover::new give the set of committees key, commitment to the set and the set of kzg points used for the commitment, constructs a new prover.</li>
</ul>
<h3>BW6 Example</h3>
<p>This section sketches a blockchain light client design exploiting APK proofs.</p>
<h2>MIPP</h2>
</body>
</html>
